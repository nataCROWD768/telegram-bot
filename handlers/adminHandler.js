const Product = require('../models/product');
const Review = require('../models/review');
const ExcelJS = require('exceljs');
const fs = require('fs').promises;
const path = require('path');

const handleAdmin = async (bot, msg) => {
    const chatId = msg.chat.id;
    await bot.sendMessage(chatId, 'üõ† –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å:', {
        reply_markup: {
            keyboard: [
                ['–ü–æ–∫–∞–∑–∞—Ç—å —Ç–æ–≤–∞—Ä—ã', '–î–æ–±–∞–≤–∏—Ç—å —Ç–æ–≤–∞—Ä'],
                ['–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–≤–∞—Ä', '–£–¥–∞–ª–∏—Ç—å —Ç–æ–≤–∞—Ä'],
                ['–ú–æ–¥–µ—Ä–∞—Ü–∏—è –æ—Ç–∑—ã–≤–æ–≤', '–ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é']
            ],
            resize_keyboard: true
        }
    });
};

const showStats = async (bot, chatId) => {
    // –ó–¥–µ—Å—å –º–æ–∂–µ—Ç –±—ã—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
};

const showProducts = async (bot, chatId) => {
    try {
        const products = await Product.find();
        if (products.length === 0) {
            await bot.sendMessage(chatId, 'üì¶ –¢–æ–≤–∞—Ä–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç');
            return;
        }

        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet('–¢–æ–≤–∞—Ä—ã');

        worksheet.columns = [
            { header: 'ID', key: '_id', width: 25 },
            { header: '–ù–∞–∑–≤–∞–Ω–∏–µ', key: 'name', width: 30 },
            { header: '–û–ø–∏—Å–∞–Ω–∏–µ', key: 'description', width: 40 },
            { header: '–¶–µ–Ω–∞ (–∫–ª—É–±)', key: 'clubPrice', width: 15 },
            { header: '–¶–µ–Ω–∞ (–∫–ª–∏–µ–Ω—Ç)', key: 'clientPrice', width: 15 },
            { header: '–†–µ–π—Ç–∏–Ω–≥', key: 'averageRating', width: 10 },
            { header: '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ', key: 'image', width: 40 }
        ];

        worksheet.getRow(1).font = { bold: true, size: 12, color: { argb: 'FFFFFFFF' } };
        worksheet.getRow(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF0088CC' } };
        worksheet.getRow(1).alignment = { vertical: 'middle', horizontal: 'center' };

        products.forEach(product => {
            worksheet.addRow({
                _id: product._id.toString(),
                name: product.name,
                description: product.description,
                clubPrice: product.clubPrice,
                clientPrice: product.clientPrice,
                averageRating: product.averageRating,
                image: product.image
            });
        });

        worksheet.eachRow((row, rowNumber) => {
            if (rowNumber > 1) {
                row.eachCell(cell => {
                    cell.border = {
                        top: { style: 'thin' },
                        left: { style: 'thin' },
                        bottom: { style: 'thin' },
                        right: { style: 'thin' }
                    };
                    cell.alignment = { vertical: 'middle', horizontal: 'left' };
                });
            }
        });

        const filePath = path.join(__dirname, '../products.xlsx');
        await workbook.xlsx.writeFile(filePath);

        await bot.sendDocument(chatId, filePath, {
            caption: '–°–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤'
        }, {
            filename: '–¢–æ–≤–∞—Ä—ã.xlsx',
            contentType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        });

        await fs.unlink(filePath);
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≤—ã–≥—Ä—É–∑–∫–∏ —Ç–æ–≤–∞—Ä–æ–≤ –≤ Excel:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–≥—Ä—É–∑–∫–µ —Ç–æ–≤–∞—Ä–æ–≤');
    }
};

const addProduct = async (bot, chatId) => {
    let productData = {};

    await bot.sendMessage(chatId, 'üì¶ –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ç–æ–≤–∞—Ä–∞. –í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ:');
    bot.once('message', async (msg) => {
        productData.name = msg.text;

        await bot.sendMessage(chatId, '–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ:');
        bot.once('message', async (msg) => {
            productData.description = msg.text;

            await bot.sendMessage(chatId, '–í–≤–µ–¥–∏—Ç–µ —Ü–µ–Ω—É (–∫–ª—É–±), —Ä—É–±.:');
            bot.once('message', async (msg) => {
                productData.clubPrice = parseInt(msg.text);
                if (isNaN(productData.clubPrice)) {
                    await bot.sendMessage(chatId, '‚ùå –¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —á–∏—Å–ª–æ–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
                    return;
                }

                await bot.sendMessage(chatId, '–í–≤–µ–¥–∏—Ç–µ —Ü–µ–Ω—É (–∫–ª–∏–µ–Ω—Ç), —Ä—É–±.:');
                bot.once('message', async (msg) => {
                    productData.clientPrice = parseInt(msg.text);
                    if (isNaN(productData.clientPrice)) {
                        await bot.sendMessage(chatId, '‚ùå –¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —á–∏—Å–ª–æ–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
                        return;
                    }

                    await bot.sendMessage(chatId, '–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞:');
                    bot.once('message', async (msg) => {
                        if (!msg.photo) {
                            await bot.sendMessage(chatId, '‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.');
                            return;
                        }

                        const photo = msg.photo[msg.photo.length - 1];
                        const fileId = photo.file_id;
                        const file = await bot.getFile(fileId);
                        const fileUrl = `https://api.telegram.org/file/bot${process.env.TELEGRAM_TOKEN}/${file.file_path}`;

                        productData.image = fileUrl;

                        try {
                            const product = new Product({
                                name: productData.name,
                                description: productData.description,
                                clubPrice: productData.clubPrice,
                                clientPrice: productData.clientPrice,
                                image: productData.image,
                                stock: 0,
                                averageRating: 0
                            });
                            await product.save();
                            await bot.sendMessage(chatId, `‚úÖ –¢–æ–≤–∞—Ä "${productData.name}" —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!`);
                        } catch (error) {
                            console.error('–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–æ–≤–∞—Ä–∞:', error);
                            await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ç–æ–≤–∞—Ä–∞');
                        }
                    });
                });
            });
        });
    });
};

const editProduct = async (bot, chatId) => {
    await bot.sendMessage(chatId, 'üì¶ –í–≤–µ–¥–∏—Ç–µ ID —Ç–æ–≤–∞—Ä–∞ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:');
    bot.once('message', async (msg) => {
        const productId = msg.text;
        const product = await Product.findById(productId);
        if (!product) {
            await bot.sendMessage(chatId, '‚ùå –¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω');
            return;
        }
        await bot.sendMessage(chatId, `–¢–µ–∫—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ:\n${product.name}|${product.description}|${product.clubPrice}|${product.clientPrice}|${product.image}\n\n–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n\`–ù–∞–∑–≤–∞–Ω–∏–µ|–û–ø–∏—Å–∞–Ω–∏–µ|–¶–µ–Ω–∞ (–∫–ª—É–±)|–¶–µ–Ω–∞ (–∫–ª–∏–µ–Ω—Ç)|URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è\``);
        bot.once('message', async (msg) => {
            const [name, description, clubPrice, clientPrice, image] = msg.text.split('|');
            if (!name || !description || !clubPrice || !clientPrice || !image) {
                await bot.sendMessage(chatId, '‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
                return;
            }
            try {
                await Product.updateOne({ _id: productId }, {
                    name,
                    description,
                    clubPrice: parseInt(clubPrice),
                    clientPrice: parseInt(clientPrice),
                    image
                });
                await bot.sendMessage(chatId, `‚úÖ –¢–æ–≤–∞—Ä "${name}" —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª—ë–Ω!`);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–æ–≤–∞—Ä–∞:', error);
                await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ —Ç–æ–≤–∞—Ä–∞');
            }
        });
    });
};

const deleteProduct = async (bot, chatId) => {
    await bot.sendMessage(chatId, 'üì¶ –í–≤–µ–¥–∏—Ç–µ ID —Ç–æ–≤–∞—Ä–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:');
    bot.once('message', async (msg) => {
        const productId = msg.text;
        const product = await Product.findById(productId);
        if (!product) {
            await bot.sendMessage(chatId, '‚ùå –¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω');
            return;
        }
        try {
            await Product.deleteOne({ _id: productId });
            await bot.sendMessage(chatId, `‚úÖ –¢–æ–≤–∞—Ä "${product.name}" —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª—ë–Ω!`);
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Ç–æ–≤–∞—Ä–∞:', error);
            await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ç–æ–≤–∞—Ä–∞');
        }
    });
};

const moderateReviews = async (bot, chatId) => {
    try {
        const reviews = await Review.find({ isApproved: false }).populate('productId', 'name');
        if (reviews.length === 0) {
            await bot.sendMessage(chatId, 'üìù –ù–µ—Ç –æ—Ç–∑—ã–≤–æ–≤ –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏—é');
            return;
        }

        for (const review of reviews) {
            const reviewText = `
                –¢–æ–≤–∞—Ä: ${review.productId.name}
                –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: ${review.username}
                –†–µ–π—Ç–∏–Ω–≥: ${'‚òÖ'.repeat(review.rating)}${'‚òÜ'.repeat(5 - review.rating)}
                –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: ${review.comment}
            `;
            await bot.sendMessage(chatId, reviewText, {
                reply_markup: {
                    inline_keyboard: [
                        [
                            { text: '–û–¥–æ–±—Ä–∏—Ç—å', callback_data: `approve_review_${review._id}` },
                            { text: '–û—Ç–∫–ª–æ–Ω–∏—Ç—å', callback_data: `reject_review_${review._id}` }
                        ]
                    ]
                }
            });
        }
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –º–æ–¥–µ—Ä–∞—Ü–∏–∏ –æ—Ç–∑—ã–≤–æ–≤:', error);
        await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –æ—Ç–∑—ã–≤–æ–≤');
    }
};

const handleAdminCallback = async (bot, callbackQuery) => {
    const chatId = callbackQuery.message.chat.id;
    const data = callbackQuery.data;

    if (data.startsWith('approve_review_')) {
        const reviewId = data.split('_')[2];
        try {
            const review = await Review.findByIdAndUpdate(reviewId, { isApproved: true }, { new: true }).populate('productId', 'name');
            if (!review) {
                await bot.sendMessage(chatId, '‚ùå –û—Ç–∑—ã–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω');
                return;
            }
            const reviews = await Review.find({ productId: review.productId, isApproved: true });
            const averageRating = reviews.length > 0
                ? reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length
                : 0;
            await Product.updateOne({ _id: review.productId }, { averageRating });
            await bot.editMessageText(`–û—Ç–∑—ã–≤ –æ–¥–æ–±—Ä–µ–Ω!\n–¢–æ–≤–∞—Ä: ${review.productId.name}`, {
                chat_id: chatId,
                message_id: callbackQuery.message.message_id
            });
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –æ–¥–æ–±—Ä–µ–Ω–∏—è –æ—Ç–∑—ã–≤–∞:', error);
            await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–¥–æ–±—Ä–µ–Ω–∏–∏ –æ—Ç–∑—ã–≤–∞');
        }
    } else if (data.startsWith('reject_review_')) {
        const reviewId = data.split('_')[2];
        try {
            const review = await Review.findById(reviewId).populate('productId', 'name');
            if (!review) {
                await bot.sendMessage(chatId, '‚ùå –û—Ç–∑—ã–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω');
                return;
            }
            await Review.deleteOne({ _id: reviewId });
            const reviews = await Review.find({ productId: review.productId, isApproved: true });
            const averageRating = reviews.length > 0
                ? reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length
                : 0;
            await Product.updateOne({ _id: review.productId }, { averageRating });
            await bot.editMessageText(`–û—Ç–∑—ã–≤ –æ—Ç–∫–ª–æ–Ω—ë–Ω –∏ —É–¥–∞–ª—ë–Ω!\n–¢–æ–≤–∞—Ä: ${review.productId.name}`, {
                chat_id: chatId,
                message_id: callbackQuery.message.message_id
            });
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è –æ—Ç–∑—ã–≤–∞:', error);
            await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–∏ –æ—Ç–∑—ã–≤–∞');
        }
    }

    bot.answerCallbackQuery(callbackQuery.id);
};

module.exports = {
    handleAdmin,
    showStats,
    showProducts,
    addProduct,
    editProduct,
    deleteProduct,
    moderateReviews,
    handleAdminCallback
};